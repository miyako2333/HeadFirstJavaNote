第1章：进入Java的世界

Java特点

**面向对象、内存管理、跨平台。**

Java如何工作？Java编译器和Java虚拟机，各有什么用？

**1.源代码 -> 2.编译器 -> 3.输出字节码 -> 4.JVM(Java虚拟机).java -> .class文件 -> 在JVM上运行**

第1步：编写源代码文件

第2步：用javac编译器编译源代码。编译器同时会检查错误，如果有错误就要改正，然后才能产出正确的输出。

第3步：编译器会产出字节码。任何支持Java的装置都能把它编译成可执行的内容。编译后的字节码与平台无关。

第4步：JVM(Java虚拟机)可以读取并执行字节码，运行Java字节码程序。

Java的程序结构是怎样的？

**类存在于源文件里面，方法存在于类中，语句存在于方法中。**

什么是源文件？源文件以.java为扩展名，其中带有类的定义。

什么是类？类中带有一个或多个方法。

什么是方法？方法必须在类中声明，方法是由一组语句组成。

每个Java程序至少有一个类，并且每个Java程序有且仅有一个main()函数。Java中所有的东西都会属于某个类。

为什么Java中所有的东西都得包含在类中？

因为**Java是面向对象语言，类是对象的蓝图。Java中，绝大多数的东西都是对象。**

如何解读Java程序的main()方法？

public class App() {

`    `public static void main (String[] args) {

`        `// 程序的入口

`    `}

}

Java虚拟机启动时，它会寻找你在命令行中所指定的类，并**以该类中的main()方法为入口函数**进行程序执行。

main()的两种用途？

**1.用于测试我们编写的Java类。2.作为入口，启动我们的Java程序。**

javac App.java      // java编译器编译这个程序

java App.class      // JVM执行这个程序


第2章：拜访对象村

当你在设计类时，要记得对象是靠类的模型塑造出来的。**对象是已知的事物，对象会执行动作。**

什么是对象（实例）？什么是实例变量？什么是方法？

**对象带有实例变量和方法**，这是类设计的一部分。

对象本身已知的状态，即实例变量，它代表对象的状态，每个对象都会独立地拥有一份该类型的值。

对象可以执行的动作，即方法，方法可以读取或操作实例变量。

类和对象之间到底有什么不同？

**类不是对象，却是用来创建对象的模型。**类是对象的蓝图，类会告诉JVM如何创建出某种类型的对象。根据一个类，JVM可以创建出无数的对象。

如何理解Java垃圾回收机制？

**堆，可自动回收垃圾的堆。**

jar包中的**manifest文件，指定了程序中唯一main()方法所在的类。**

第3章：认识变量

如何理解Java变量？

Java变量就像是杯子，是一种容器，用于承载某种事物，它有大小和类型。**Java编译器不允许将大杯的内容放到小杯中，反过来则可以**。一旦数组被声明出来，你就只能装入所声明类型的元素。double类型的变量不能装入int数组中，但是int类型的变量可以装入到double类型的数组中。


Java变量有哪两种类型？

1\.八种primitive主数据类型：**boolean / char / byte / short / int / long / float / double**

2\.引用类型：引用到对象的变量。对象只会存在于可回收垃圾堆上。

**Java变量必须得有类型和名称:**

Dog[] dogs = new Dog[7];

实例变量和局部变量有哪些区别？

实例变量是声明在类中的，可以不初始化。

局部变量是声明在方法中的，在被使用之前，必须先初始化。方法的参数，也属于局部变量。

第4章：对象的行为

对象中，实例变量和方法之间有着怎样的关系？

**状态影响行为，行为影响状态。实例变量即状态，方法即行为。**

什么是形参(parameter)和实参(argument)？

我们可以给方法传入参数。实参是传给方法的值。当实参传入方法后就成了形参。

给方法传入实参时，实参的顺序、类型、数量必须与形参的顺序、类型、数量完全一致。

你还可以把变量当作实参传入方法，只要其类型符合要求即可。

方法的参数传递为什么是值传递？什么是值传递？

Java方法的参数传递是值传递形式，即通过拷贝传递。实参进入方法之后就成了形参，形参的变化不会改变实参，这就是值传递的好处。

什么是方法的返回值？

在Java中，方法可以有返回值，每个方法都必须显示地指明返回值类型。如果方法没有返回值，指明为void类型即可。

什么是Getter和Setter ？

**Getter 与 Setter，前者用于返回实例变量的值，后者用于设定实例变量的值**。

为什么要封装？为什么把类中的变量暴露出去会很危险？如何对变量数据进行隐藏？

**把实例变量标记为private私有的，并提供public公有的getter和setter来控制实例变量的存取动作。**

封装有什么好处？

**封装会对我们的实例变量加上绝对领域，因此没有人能够恶搞我们的实例变量。**

数组中的元素，还可以是对象。


第5章：超强力方法

什么是面向对象的编程思维？

所谓面向对象，就是要专注于程序中出现的事物，而不是过程。

什么是伪码、测试码、真实码？分别有什么用？

伪码的作用是帮助你专注于逻辑，而不需要顾虑到程序的语法。

测试码，用于程序代码的测试。

真实码，即实际设计出来的真正Java程序代码。

Java程序应该从高层的设计开始。通常在创建新的类时，要写出“**伪码->测试码->真实码**”。

有哪些循环语句？

for循环、while循环、foreach循环

有哪两种强制类型转换？

int a = (int)(Math.random()\*5);     // 把非int类型的数字，强转为int类型

int b = Integer.parsetInt("100");   // 把字段串强转为int类型

**i++ 和 ++i区别**



第6章：使用Java函数库

**ArrayList 和 一般数组区别**

什么是Java包？

在java中，**类是被包装在包中的**。要使用API中的类，你必须知道它被放在哪个包中。

使用java类的完整名称：

java.util.ArrayList<Dog> list = new java.util.ArrayList<Dog>();

public void go(java.util.ArrayList<Dog> list) { };

public java.util.ArrayList<Dog> foo() { };

**除了java.lang包之外，其它的java包的类在被使用时，都需要使用类的全名**，即java.xxx.className形式。或者在程序开头处使用import指令导入所需要的类。


第7章：继承与多态

继承与方法重写override，什么是方法重写？

**由子类重新定义从父类中继承来的方法，将其改变或延伸**。成员变量不存在重写这个说法。

public void roam() {

`  `// 继承父类方法的功能

`  `**super.roam();**

`  `// 扩展的功能

}

区分 IS-A 与 HAS-A 关系

**IS-A，表示二者具有继承关系，这是一种单向的链式关系。**

**HAS-A，表示二者是包含关系。**

四种访问控制修改符，它们有哪些区别？

private < default < protected < public

**public类型的成员，会被继承。private类型的成员，不会被继承。**

一个类的成员，包含自己定义的变量和方法，还包含从父类所继承下来的成员。

继承到底有什么意义？

避免重复的代码；定义共同的协议。

什么是多态？

**对象的声明、创建与赋值：**在上述对象的创建过程中，引用类型和对象的类型相同。在多态中，引用类型和对象的类型可以不同。

继承关系中，方法覆写要遵守哪些约定？

参数必须要一样，且返回类型必须要兼容。

不能降低方法的存取权限。

什么是方法重载？

方法名相同，但参数列表不同，即是重载，它与方法的返回值类型、方法的存取权限都无关。


第8章：接口与抽象类（深入多态）

什么是抽象类？

**用abstract关键字声明抽象类**，抽象类不能用new 关键字进行实例化。在设计继承结构时，必须决定清楚什么类是抽象类，什么类是具体类。编译器不会让你初始化一个抽象类。抽象类，**除了被继承以外，是没有其它任何用途**的。抽象类中，必须包含有抽象方法，还可以包含非抽象方法。

什么是抽象方法？

即**用 abstract关键字声明的方法，抽象方法没有方法实体，即没有具体的实现过程**。拥有抽象方法的类，必须声明为抽象类。抽象类中的抽象方法，用于规定一组子类共同的协议。

在继承过程中，**具体类必须实现抽象父类的所有抽象方法**

多态的使用

在Java中，所有类都是从Object这个类继承而来的，Object是所有类的源头，它是所有类的父类。Object有很有用的方法，如 equals(), getClass(), hashCode(), toString()等。

在使用多态时，要注意对象多种类型之间的差异。如下代码：

Dog dog1 = new Dog();

Animal dog2 = new Dog();

Object dog3 = new Dog();

注意这三个dog对象的区别： dog1 拥有 Dog / Animal / Object中所有的方法。dog2 拥有 Animal / Object 中的方法，不能调用 Dog 类特有的方法。 dog3 只拥有Object 中的方法，不能调用 Animal / Dog类中的方法。

什么是接口？

**接口，是一种100%纯抽象的类。**接口中的所有方法，都是未实现的抽象方法。

为什么需要接口？

接口存在的意义，就是为了解决Java多重继承带来的致命方块问题。为什么接口可以解决致命方块的问题呢？因为在接口中，所有方法都是抽象的，如此一来，子类在实现接口时就必须实现这些抽象方法，因此Java虚拟机在执行期间就不会搞不清楚要用哪一个继承版本了。

// interface关键字，用于定义接口

public interface Pet {

`    `public abstract void beFriendly();

}

// 继承抽象父类 Animal类， 实现 Pet接口

public class Dog extends Animal implements Pet {

`    `// 实现接口中的抽象方法

`    `public void beFriendly() {

`        `System.out.println("实现 Pet接口中的 beFriendly()方法");

`    `}

}

super关键字代表什么？

super代表父类，**在子类中使用 super关键字指代父类，通过super还可以调用父类的方法**。



第9章：构造器与垃圾收集器

什么是栈与堆？ 堆（heap）、栈（stack）

当Java虚拟机启动时，它会从底层操作系统中取得一块内存，以此区段来执行Java程序。实例变量保存在所属的对象中，位于堆上。如果实例变量是对象引用，则这个引用和对象都是在堆上。

构造函数与对象创建的三个步骤

对象创建的三个步骤：**声明、创建、赋值。**

构造函数，让你有机会介入 new 的过程。构造函数，没有显示的指定返回值类型，构造函数不会被继承。如果一个类，没有显示地编写构造器函数，Java编译器会默认地为该类添加一个没有参数的构造器函数。反之，Java编译器则不会再添加任何默认的构造函数。

什么构造器函数重载？

即一个类，有多个构造器函数，且它们的**参数都不能相同**，包括参数顺序不同、或者参数类型不同、或者参数个数不同。重载的构造器，代表了该类在创建对象时可以有多种不同的方式。

什么是构造函数链？ super()

构造函数在执行的时候，**第一件事就是去执行它的父类的构造函数**。这样的链式过程，就被称为“构造函数链（Constructor Chaining）”。

如果一个类，没有显示地书写构造器函数，Java编译器会为它添加上默认的无参构造器。

在类中，this 和 super 有什么区别？ this() 和 super() 有什么区别？

使用 this() 可以在某个构造函数中调用同一个类的另外一个构造函数。 this() 只能在构造函数中使用，并且必须是第一行。 this() 和 super() 不能同时使用。

对象、变量的生命周期是怎样的？

对象的生命周期决定于对象引用变量的生命周期，如果引用还在，则对象也在；如果引用死了，对象会跟着被 GC 回收。当最后一个引用消失时，对象就会变成可回收的。

局部变量，只存活在对象的方法中，方法结束，局部变量就死了。

实例变量，存活在对象中，它的生命周期与对象一致。


第10章：数字与静态性

Math 有什么特点？

在 Java 中没有东西是全局(global)的。但，Math 方法是接近全局的方法。Math中所有方法都静态方法。

非静态方法与静态方法，有哪些差别？

静态方法，使用 static 关键字声明，以类的名称进行调用。

非静态方法，以实例对象进行调用，没有 static修饰。

静态变量有哪些特点？静态变量与非静态变量有哪些区别？

静态变量，会被同类的所有实例共享，因为它隶属于类。**静态变量，在类第一次载入时初始化。静态变量，会在所有对象创建之前进行初始化，也会在任何静态方法执行之前就初始化。静态变量，只能由类来调用。**

非静态变量，**只被单个对象独有，它隶属于实例**。非静态变量，在类实例化时进行初始化。

实例对象不会维护静态变量的拷贝，静态变量由类进行维护。非静态变量由实例对象进行维护。

如何声明一个静态常量？

public static final double PI = 3.1415926;

public 表示可供各方读取。 static 表示静态。 final 表示“固定不变”。 常量的标识符，一般建议字母大写，字母之间可以用下划线连接。

深入理解 final

final 的核心意思是，它所修饰的元素不能被改变。final 不仅可以修饰变量，还可以修饰方法和类。

什么是主数据类型的包装类？

Boolean / Character / Byte / Short / Integer / Long / Float / Double

主数据类型的包装类，都放在 java.lang 中，所以无需 import 它们。当你需要以对象的方式来处理主数据类型时，你就需要用包装类把它们包装起来，Java5.0之前必须这么做。



第11章：异常处理

如果你把有风险的程序代码包含在 try/catch 块中，那么编译器会放心很多。 try/catch 块会告诉编译器你确实知道所调用的方法会有风险，并且也已经准备好要处理它。

try {

`    `// 有风险的行为

`    `Sequencer seq = MidiSystem.getSequencer();

`    `System.out.println("had got a sequencer");

} catch (MidiUnavailableException ex) {

`    `System.out.println(ex);

} finally {

`    `System.out.println("总会被执行！");

}

异常也是多态的，Exception子类的实例对象，都是 Exception类型的。编译器会忽略 RuntimeException类型的异常，RuntimeException类型的异常不需要声明或被包含在 try/catch 块中。

**如果 try 或 catch 块中有 return 指令，finally还是会执行。流程会跳到 finally执行，finally执行完毕后再回跳到return 指令。**

异常从哪里来？

**异常是由方法 throws 来的。**

public void doLaundry() throws PantsException, LingerieException {}

从上面看，程序有两种方式来处理异常，一种是使用 try/catch 来捕获异常，另一种是使用 throws 把异常抛给下一个调用者。


第14章：序列化与文件的输入输出

如果只有自己写的Java程序会用到这些数据。**用序列化（Serialization），将被序列化的对象写到文件中。然后就可以让你的程序去文件中读取序列化的对象，并把它们展开回到活生生的状态。**

如果要让类能够序列化，就要实现Serializable

Serializable接口，此接口并没有任何方法需要被实现。它唯一的目的就是声明有实现它的类是可以被序列化的。也就是说，此类型的对象可以通过序列化的机制来存储。如果某个类是可以序列化的，则它的子类也自动地可以序列化。

序列化是全有或全无的，即对象序列化时不存在“一部分序列化成功、另一部分序列化失败”的情况。

那么在一个可序列化的类中，如何指定部分实例变量不执行序列化呢？

如果希望某个实例变量不能或不应该被序列化，就把它**标记为 transient**（瞬时）的，即可。

如何从文件中读取序列化对象，并将其还原？

把对象恢复到存储时的状态。**解序列化，可看成是序列化的反向操作。**

序列化（存储）和解序列化（恢复）的过程，到底到生了什么事？

你可以通过序列化来存储对象的状态，使用ObjectOutputStream来序列化对象。Stream是连接串流或是链接用的串流，连接串流用来表示源或目的地、文件、网络套接字连接。链接用串流用来链接连接串流。使用FileOutputStream将对象序列化到文件上。静态变量不会被序列化，因为所有对象都是共享同一份静态变量值。

对象必须实现Serializable 这个接口，才能被序列化。如果父类实现了它，则子类就自动地有实现。

解序列化时，所有的类都必须能让Java虚拟机找到。读取对象的顺序必须与写入时的顺序一致。


第15章：网络与线程（网络联机）

什么是 Socket 连接？

**Socket 是个代表两台机器之间网络连接的对象（java.net.Socket）**。什么是连接？就是两台机器之间的一种关系，让两个软件相互认识对方，能够**彼此发送和接收数据**。在Java中，这是一种让运行在Java虚拟机上的程序能够找到方法去通过实际的硬件（比如网卡）在机器之间传送数据的机制。

如何创建一个 Socket 连接呢？

要创建 Socket，得知道两项关于服务器的信息：它在哪里（IP地址）？它使用的是哪个端口号？

Socket chat = new Socket("196.164.1.103", 3000);

如何从 Socket 上读取数据？

用串流来通过 Socket 连接来沟通。使用 **BufferedReader** 从 Socket上读取数据。在Java中，大部分的输入与输出工作并不在乎链接串流的上游是什么，也就是说可以使用BufferedReader读取数据而不用管串流是来自文件还是Socket。

// 1 - 建立对服务器的 Socket 连接

Socket chat = new Socket("192.168.1.100", 3000);

// 2 - 建立连接到Socket上低层的输入串流

InputStreamReader stream = new InputStreamReader(chat.getInputStream());

// 3 - 建立Buffer来提升数据读取的效率

BufferedReader reader = new BufferedReader(stream);

// 4 - 读取数据

String msg = reader.readLine();

read.close();

如何向 Socket 中写入数据？

使用 PrintWriter 是最标准的做法。它的 print() / println() 方法，就跟 System.out 里的方法刚好一样。

// 1 - 对服务器建立 Socket 连接

Socket chat = new Socket("192.168.1.100", 3000);

// 2 - 建立连接到 Socket 的 PrintWriter

PrintWriter writer = new PrintWriter(chat.getOutputStream());

// 3 - 写入数据

writer.println("hello world");

writer.print("hello socket");

什么是 Java 线程？

java.lang.Thread类，表示Java中的线程，使用它可以创建线程实例。

每个Java应用程序都会启动一个**主线程——把 main() 方法放进它自己执行空间的最开始处**。Java虚拟机会负责主线程的启动。

怎么理解多线程的工作原理？

当有超过一个以上的执行空间时，看起来像是有好几件事情同时在发生。实际上，只有真正的多核处理器系统才能够同时做好几件事情。使用Java多线程可以让它看起来好像同时在做多个事情。也就是说，执行运作可以在执行空间中非常快速地来回切换，因此你会感觉到每项任务都在执行。线程要记录的一项事物是目前线程执行空间做到了哪里。Java虚拟机，会在多个线程之间来回切换，直到它们都执行完为止。

如何创建一个新的线程？

对一个线程而言，Thread线程就是一个工人，而Runnable就是这个工作的工作。**Runnable**带有会放在执行空间的第一项的方法：run() 。Thread对象不可以重复使用，一旦该线程的run()方法完成后，该线程就不能再重新启动了。

public class TestThread implements Runnable {

`    `// 实现 Runnable 接口的 run 方法

`    `public void run() {

`        `System.out.println("执行");

`    `}

`    `public static void main(String[] args) {

`        `// 创建线程的工作任务

`        `Runnable threadObj = new TestThread();

`        `// 创建线程，并把工作任务传递给线程

`        `Thread myThread = new Thread(threadObj);

`        `// 启动线程

`        `myThread.start();

`    `}

}

线程有哪三种状态？

线程实例一旦 start() 后，会有三种可能的状态：可执行状态、执行中状态、堵塞状态。在不发生堵塞的情况下，线程会在可执行状态和执行中状态之间来来回回地切换。

什么是线程调度器？

线程调度器会决定哪个线程从等待状态中被挑出来运行，以及何时把哪个线程送回等待被执行状态。它会决定某个线程要运行多久，当线程被踢出去时，调度器也会指定线程要回去等待下一个机会或者是暂时地堵塞。我们无法控制线程调度器，没有API可以调用调度器，调度器在不同的Java虚拟机上也不尽相同。

线程休眠 **Thread.sleep()**

如果想要确定其它线程有机会执行的话，就把线程放进休眠状态。当线程醒来的时候，它会进入可以执行状态等待被调度器挑出来执行。使用 sleep() 能让程序变得更加可预测。

线程，可能会导致并发性问题（concurrency），发生竞争状态，竞争状态会引发数据的损毁。两个或以上的线程存取单一对象的数据，也就是说两个不同执行空间上的方法都在堆上对同一对象执行 getter / setter。

如何解决线程并发性引起的竞争状态问题呢？

使用 ***synchronized 关键字***来修饰线程任务中的方法，它代表线程需要一把钥匙来存取被同步化过的线程。要保护数据，就把作用在数据上的方法同步化。

什么是同步化的死锁问题？

同步化死锁会发生，是因为**两个线程相互持有对方正在等待的东西**。没有方法可以脱离这个情况，所以两个线程只好停下来等，一直等。在Java中，并没有处理死锁的内置机制，所以编写程序时要注意这一问题，避免发生死锁。



第16章：集合与泛型（数据结构）

有哪些常用的集合？

ArrayList

TreeSet 以有序状态保存并可防止数据重复

HashMap 以键值对的形式保存数据

LinkedList 针对经常插入或删除中间元素所设计的高效率集合

HashSet 防止重复的集合，可快速地寻找相符的元素

LinkedHashMap

什么是泛型？为什么使用泛型？

关于泛型，最重要的 3 件事

如何创建被泛型化类的实例？

如何声明指定泛型类型的变量？多态遇到泛型类型会怎样？

如何声明或调用泛型类型的方法？

// 创建被泛型化的类

List<Song> songList = new ArrayList<Song>();

// 声明泛型类型的方法

public void foo(List<Song> list) {}

// 调用泛型类型的方法

x.foo(songList);

集合有哪 3 类主要的接口？

List，是一种知道索引位置的集合，这是对待顺序的好帮手。

Set，不允许重复的集合，它注重独一无二的性质。

Map，使用键值对存储数据的集合，用 key 来搜索。

第17章：包、jar存档文件和部署（发布程序）

Java程序，是由一组类所组成的，这就是开发过程的输出。本章将讨论如何组织、包装和部署Java程序。

如何组织Java代码文件？

在 source目录下放置 .java 源文件；在 classes 目录下放置 .class 编译结果。**使用 -d 选项，可以指定编译结果的存储目录。**

javac  -d  ../classes  MyApp.java

mainifest文件 与 JAR包

JAR即 Java ARchive。这种文件是个 pkzip 格式的文件，它能够让你把一组类文件包装起来，所以交付时只需要一个 JAR文件即可。它类似 Linux上的 tar命令。可执行的 JAR 代表用户不需要把文件抽出来就能运行，这个秘密就在于 mainifest文件，它携带着 JAR包的若干信息，并且能告诉Java虚拟机哪个类中含有 main() 方法。

大部分的Java应用，都是以可执行的JAR包来部署的。Java虚拟机能够从JAR包中载入类，并调用该类中的 main() 方法。事实上，整个应用程序都可以包在 JAR包中。一旦 main() 方法开始执行，Java虚拟机就不会在乎类是从哪里来的，只要能够找到就行。其中一个来源就是 classpath 指定位置的所有 JAR文件。

Java虚拟机必须要能找到JAR，所以它必须在 classpath 下。让 JAR曝光的最好方式就是把 JAR放置在工作目录下。Java虚拟机会检查 JAR包中的 manifest文件以寻找入口，如果没有找到就会发生运行期间异常。

